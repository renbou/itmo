# Лабораторная работа по графам. Алгоритмы на строках

## Задача A. Сравнения подстрок
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дана строка s. Ответьте на m запросов вида: равны ли подстроки s[a..b] и s[c..d].

### Формат входных данных
В первой строке ввода записана строка s (1 ≤ |s| ≤ 10⁵).  
Во второй строке записано целое число m — количество запросов (0 ≤ m ≤ 10⁵).  
В следующих m строках четверки чисел a, b, c, d (1 ≤ a ≤ b ≤ |s|, 1 ≤ c ≤ d ≤ |s|).

### Формат выходных данных
Выведите m строк. Выведите Yes, если подстроки совпадают, и No иначе.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| trololo<br>3<br>1 7 1 7<br>3 5 5 7<br>1 1 1 5 | Yes<br>Yes<br>No |

**[Решение/Solution](src/a.cpp)**

## Задача B. Префикс-функция
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Постройте префикс-функцию для заданной строки s.

### Формат входных данных
Первая строка входного файла содержит s (1 ≤ |s| ≤ 10⁶). Строка состоит из букв латинского алфавита.

### Формат выходных данных
Выведите значения префикс-функции строки s для всех индексов 1, 2, ..., |s|.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| aaaAAA | 0 1 2 0 0 0 |

**[Решение/Solution](src/b.cpp)**

## Задача C. Z-функция
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Постройте Z-функцию для заданной строки s.

### Формат входных данных
Первая строка входного файла содержит s (1 ≤ |s| ≤ 10⁶). Строка состоит из букв латинского алфавита.

### Формат выходных данных
Выведите значения Z-функции строки s для индексов 2, 3, ..., |s|.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| aaaAAA | 2 1 0 0 0 |
| abacaba | 0 1 0 3 0 1 |

**[Решение/Solution](src/c.cpp)**

## Задача D. Быстрый поиск подстроки в строке
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Даны строки p и t. Требуется найти все вхождения строки p в строку t в качестве подстроки.

### Формат входных данных
Первая строка входного файла содержит p, вторая — t (1 ≤ |p|, |t| ≤ 10⁶). Строки состоят из букв латинского алфавита.

### Формат выходных данных
В первой строке выведите количество вхождений строки p в строку t. Во второй строке выведите в возрастающем порядке номера символов строки t, с которых начинаются вхождения p. Символы нумеруются с единицы.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| aba<br>abaCaba | 2<br>1 5 |

**[Решение/Solution](src/d.cpp)**

## Задача E. Поиск периода
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дана строка s. Требуется найти минимальную по длине строку t, такую что s представима в виде конкатенации одной или нескольких строк t.

### Формат входных данных
Первая строка входного файла содержит s (1 ≤ |s| ≤ 10⁶). Строка состоит из букв латинского алфавита.

### Формат выходных данных
Выведите длину искомой строки t.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| abcabcabc | 3 |
| abacaba | 7 |

**[Решение/Solution](src/e.cpp)**

## Задача F. Подстроки-3
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Даны K строк из маленьких латинских букв. Требуется найти их наибольшую общую подстроку.

### Формат входных данных
В первой строке число K (1 ≤ K ≤ 10).  
В следующих K строках — собственно K строк (длины строк от 1 до 10 000).

### Формат выходных данных
Наибольшая общая подстрока.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| 3<br>abacaba<br>mycabarchive<br>acabistrue | cab |

**[Решение/Solution](src/f.cpp)**

## Задача G. Множественный поиск
> Ограничение по времени: 3 секунды  
  Ограничение по памяти: 1024 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан массив строк sᵢ и строка t. Требуется для каждой строки sᵢ определить, встречается ли она в t как подстрока.

### Формат входных данных
Первая строка входного файла содержит целое число n — число элементов в s (1 ≤ n ≤ 10⁶). Следующие n строк содержат по одной строке sᵢ. Сумма длин всех строк из s не превосходит 10⁶. Последняя строка входного файла содержит t (1 ≤ t ≤ 10⁶). Все строки состоят из строчных латинских букв.

### Формат выходных данных
Для каждой строки sᵢ выведите «YES», если она встречается в t и «NO» в противном случае. Строки нумеруются в порядке появления во входном файле.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| 3<br>abc<br>abcdr<br>abcde<br>xabcdef | YES<br>NO<br>YES |

**[Решение/Solution](src/g.cpp)**

## Задача H. Множественный поиск 2
> Ограничение по времени: 3 секунды  
  Ограничение по памяти: 1024 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан массив строк sᵢ и строка t. Требуется для каждой строки sᵢ определить, сколько раз она встречается в t как подстрока.

### Формат входных данных
Первая строка входных данных содержит целое число n (1 ≤ n ≤ 10⁶) — число элементов в s.  
Следующие n строк содержат по одной строке sᵢ. Гарантируется, что сумма длин всех строк из s не превосходит 10⁶.  
Последняя строка входных данных содержит строку t (1 ≤ |t| ≤10⁶).  
Все строки состоят из строчных латинских букв.

### Формат выходных данных
Для каждой строки sᵢ выведите количество её вхождений в строку t в том же порядке, что и во входных данных.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| 3<br>abc<br>abcdr<br>abcde<br>xabcdef | 1<br>0<br>1 |

**[Решение/Solution](src/h.cpp)**

## Задача I. Множественный поиск 3
> Ограничение по времени: 3 секунды  
  Ограничение по памяти: 1024 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан массив строк sᵢ и строка t. Требуется для каждой строки sᵢ найти самое левое и самое правое вхождение в t как подстроки.

### Формат входных данных
Первая строка входных данных содержит целое число n (1 ≤ n ≤ 10⁶) — число элементов в s. Следующие n строк содержат по одной строке sᵢ. Гарантируется, что сумма длин всех строк из s не превосходит 10⁶. Последняя строка входных данных содержит строку t (1 ≤ |t| ≤10⁶). Все строки состоят из строчных латинских букв.

### Формат выходных данных
Для каждой строки sᵢ выведите два числа: индексы самой левой и самой правой позиции, в которых она встречается в t. Если строка не встречается в t ни разу, выведите  - 1  - 1. Строки нумеруются в порядке появления во входном файле. Позиции нумеруются с 0.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| 3<br>ab<br>bcd<br>abde<br>abcdab | 0 4<br>1 1<br>-1 -1 |

**[Решение/Solution](src/i.cpp)**

## Задача J. Суффиксный массив
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 512 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Постройте суффиксный массив для заданной строки s, для каждых двух соседних суффиксов найдите длину максимального общего префикса.

### Формат входных данных
Первая строка входного файла содержит строку s (1 ≤ |s| ≤ 400 000). Строка состоит из строчных латинских букв.

### Формат выходных данных
В первой строке выведите |s| различных чисел — номера первых символов суффиксов строки s так, чтобы соответствующие суффиксы были упорядочены в лексикографически возрастающем порядке. Во второй строке выведите |s| - 1 чисел — длины наибольших общих префиксов.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| ababb | 1 3 5 2 4<br>2 0 1 1 |

**[Решение/Solution](src/j.cpp)**

## Задача K. Количество подстрок
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 512 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Вычислите количество различных подстрок строки s.

### Формат входных данных
Единственная строка входного файла содержит строку s (1 ≤ |s| ≤ 400 000). Строка состоит из строчных латинских букв.

### Формат выходных данных
Выведите одно число — ответ на задачу.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| ababb | 11 |

**[Решение/Solution](src/k.cpp)**

## Задача L. Циклические сдвиги
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 512 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

k-м циклическим сдвигом строки S называется строка, полученная перестановкой k первых символов строки S в конец строки.  
Рассмотрим все различные циклические сдвиги строки S и отсортируем их по возрастанию. Требуется вычислить i-ю строчку этого массива.  
Например, для строки abacabac существует четыре различных циклических сдвига: нулевой (abacabac), первый (bacabaca), второй (acabacab) и третий (cabacaba). После сортировки по возрастанию получится такой массив: abacabac, acabacab, bacabaca, cabacaba.

### Формат входных данных
В первой строке входного файла записана строка S, длиной не более 100 000 символов с ASCII-кодами от 32 до 126. Во второй строке содержится единственное целое число k (1 ≤ k ≤ 100 000).

### Формат выходных данных
В выходной файл выведите k-й по возрастанию циклический сдвиг строки S, или слово IMPOSSIBLE, если такого сдвига не существует.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| abacabac<br>4 | cabacaba |
| abacabac<br>5 | IMPOSSIBLE |

**[Решение/Solution](src/l.cpp)**

## Задача M. Наибольшая общая подстрока
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 512 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Найдите наибольшую общую подстроку строк s и t.

### Формат входных данных
Первая строка входного файла содержит строку s, вторая — t (1 ≤ |s|, |t| ≤ 100, 000). Строки состоят из строчных латинских букв.

### Формат выходных данных
Выведите одну строку — наибольшую общую подстроку строк s и t. В случае, если ответ не единственный, выведите минимальный лексикографически.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| bababb<br>zabacabba | aba |

**[Решение/Solution](src/m.cpp)**