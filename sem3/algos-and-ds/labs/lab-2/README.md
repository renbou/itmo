# Лабораторная работа по графам. Кратчайшие пути. Игры.

## Задача A. Флойд
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами. Гарантируется, что в графе нет циклов отрицательного веса.

### Формат входных данных
В первой строке вводится единственное число N (1 ≤ N ≤ 100) — количество вершин графа. В следующих N строках по N чисел задается матрица смежности графа (j-ое число в i-ой строке — вес ребра из вершины i в вершину j). Все числа по модулю не превышают 100. На главной диагонали матрицы — всегда нули.

### Формат выходных данных
Выведите N строк по N чисел — матрицу расстояний между парами вершин, где j-ое число в i-ой строке равно весу кратчайшего пути из вершины i в j.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| 4<br>0 5 9 100<br>100 0 2 8<br>100 100 0 7<br>4 100 100 0 | 0 5 7 13<br>12 0 2 8<br>11 16 0 7<br>4 9 11 0 |

**[Решение/Solution](src/a.cpp)**

## Задача B. Кратчайший путь – 2
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан неориентированный связный взвешенный граф. Найдите кратчайшее расстояние от первой вершины до всех вершин.

### Формат входных данных
В первой строке входного файла два числа: n и m (2 ≤ n ≤ 30 000, 1 ≤ m ≤ 400 000), где n — количество вершин графа, а m — количество ребер.  
Следующие m строк содержат описание ребер. Каждое ребро задается стартовой вершиной, конечной вершиной и весом ребра. Вес каждого ребра — неотрицательное целое число, не превосходящее 10⁴.

### Формат выходных данных
Выведите n чисел — для каждой вершины кратчайшее расстояние до нее.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| 4 5<br>1 2 1<br>1 3 5<br>2 4 8<br>3 4 1<br>2 3 3 | 0 1 4 5 |

**[Решение/Solution](src/b.cpp)**

## Задача C. Цикл отрицательного веса
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан ориентированный граф. Определите, есть ли в нем цикл отрицательного веса, и если да, то выведите его.

### Формат входных данных
Во входном файле в первой строке число N (1 ≤ N ≤ 100) — количество вершин графа. В следующих N строках находится по N чисел — матрица смежности графа. Все веса ребер не превышают по модулю 10 000. Если ребра нет, то соответствующее число равно 100 000.

### Формат выходных данных
В первой строке выходного файла выведите «YES», если цикл существует или «NO» в противном случае. При его наличии выведите во второй строке количество вершин в искомом цикле и в третьей строке — вершины входящие в этот цикл в порядке обхода.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| 2<br>0 -1<br>-1 0 | YES<br>2<br>2 1 |

**[Решение/Solution](src/c.cpp)**

## Задача D. Кратчайший путь длины K
> Ограничение по времени: 4 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан ориентированный граф. Найдите кратчайшие пути, состоящие из K рёбер, от S до всех вершин.

### Формат входных данных
В первой строке дано целых четыре целых числа: 1 ≤ N, M ≤ 10⁴ — количества вершин и рёбер, 0 ≤ K ≤ 100 — количество рёбер в кратчайших путях, 1 ≤ S ≤ N — начальная вершина.  
В последующих M строках даны тройки целых чисел aᵢ, bᵢ, wᵢ — начало и конец ребра, а также его вес (1 ≤ aᵢ, bᵢ ≤ N, −10⁵ ≤ wᵢ ≤ 10⁵).

### Формат выходных данных
Выведите ровно N чисел по одному в строке. i-е число — длина минимального пути из ровно K рёбер из S в i, или −1, если пути не существует.

### Пример
| стандартный ввод | стандартный вывод
| --- | --- |
| 3 3 1 1<br>1 2 100<br>2 3 300<br>1 3 2 | -1<br>100<br>2 |
| 3 3 2 1<br>1 2 100<br>2 3 300<br>1 3 2 | -1<br>-1<br>400 |

**[Решение/Solution](src/d.cpp)**

## Задача E. Кратчайшие пути
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Вам дан взвешенный ориентированный граф и вершина s в нём. Для каждой вершины графа u выведите длину кратчайшего пути от вершины s до вершины u.

### Формат входных данных
Первая строка входного файла содержит три целых числа n, m, s — количество вершин и ребёр в графе и номер начальной вершины соответственно (2 ≤ n ≤ 2 000, 1 ≤ m ≤ 5 000).  
Следующие m строчек описывают рёбра графа. Каждое ребро задаётся тремя числами — начальной вершиной, конечной вершиной и весом ребра соответственно. Вес ребра — целое число, не превосходящее 10¹⁵ по абсолютной величине. В графе могут быть кратные рёбра и петли.

### Формат выходных данных
Выведите n строчек — для каждой вершины u выведите длину кратчайшего пути из s в u. Если не существует пути между s и u, выведите «*». Если не существует кратчайшего пути между s и u, выведите «-».

### Пример
| стандартный ввод | стандартный вывод |
| --- | --- |
| 6 7 1<br>1 2 10<br>2 3 5<br>1 3 100<br>3 5 7<br>5 4 10<br>4 3 -18<br>6 1 -1 | 0<br>10<br>-<br>-<br>-<br>\* |

**[Решение/Solution](src/e.cpp)**

## Задача F. В поисках утраченного кефира
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Школьник Вася хочет найти запасы спрятанного кефира. По легенде, кефир находится в домиках a, b или c. Вася хочет проверить каждый из этих трёх домиков, потратив на это минимальное количество времени.  
Местность, в которой находится Вася представляет собой n домиков, пронумерованных числами от 1 до n. Некоторые из домиков соединены дорогами, по которым можно ходить в обе стороны. Время прохождения i-й дороги составляет wᵢ секунд. Путём в графе называется непустая последовательность вершин, такая что все соседние вершины соединены дорогой. Требуется помочь Васе найти путь, содержащий вершины a, b, c, такой что суммарное время прохождения всех дорог на пути минимально. При этом, если мы прошли по какой-то дороге дважды (или более), то и время её прохождения следует учитывать соответствующее количество раз. Начинать свой путь Вася может из любой вершины.  
Гарантируется, что a, b, c — попарно различные домики.

### Формат входных данных
В первой строке ввода записаны два числа n и m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 200 000) — количество домиков в ЛКШ и дорог между ними соответственно.  
Следующие m строк содержат описания дорог, по одному в строке. Каждая из дорог задаётся тройкой чисел uᵢ, vᵢ, wᵢ (1 ≤ uᵢ, vᵢ ≤ n, 1 ≤ wᵢ ≤ 10⁹) — номерами соединённых домиков и временем, затрачиваемым на прохождение данной дороги. По каждой дороге разрешено ходить в обе стороны. Гарантируется, что любая пара домиков соединена не болee чем одной дорогой. Также гарантируется, что нет дороги, соединяющей домик с самим собой.  
В последней строке записаны три попарно различных числа a, b, c (1 ≤ a, b, c ≤ n).

### Формат выходных данных
Выведите одно целое число — минимальное возможное время, которое нужно затратить на прохождение пути, содержащего домики a, b и c. Если пути, содержащего все три домика не существует, то выведите -1.

### Пример
| стандартный ввод | стандартный вывод |
| --- | --- |
| 4 4<br>1 2 3<br>2 3 1<br>3 4 7<br>4 2 10<br>1 4 3 | 11 |
| 4 2<br>1 2 10<br>2 3 5<br>1 2 4 | -1 |

### Примечание
В первом примере путь 1–2–3–4 является минимальным (11 секунд). Например, путь 1–2–4–3 не подходит, так как занимает больше времени (20 секунд), а путь 3–4–2 не подходит, так как домик a оказывается не посещенным.  
Во втором примере не существует способа добраться от домика b до домика c, поэтому искомого пути не существует.

**[Решение/Solution](src/f.cpp)**

## Задача G. Бемби
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Существует страна, в которой n городов. Города пронумерованы от 1 до n. Также в этой стране существуют двунаправленные дороги. Каждая дорога соединяет пару городов. Для каждого i, автомобильная дорога i соединяет города aᵢ и bᵢ.  
Бемби — это олень, который любит путешествовать по дорогам. Движение по дороге i (в любом направлении) занимает у оленя dᵢ минут. Бемби ненавидит города и из-за этого никогда в них не задерживается.  
Бемби начинает путешествие из города номер 1. Через t минут он желает оказаться в городе n. Вы должны узнать, может ли Бемби достигнуть город n ровно через t минут.

### Формат входных данных
Первая строка содержит два целых числа n и m — количество городов и дорог в стране (1 ≤ n, m ≤ 50).  
Следующие m строк описывают дороги. Каждая строка состоит из чисел aᵢ, bᵢ и dᵢ — концы дороги и ее длина (1 ≤ aᵢ, bᵢ ≤ n; 1 ≤ dᵢ ≤ 10⁴).  
Последняя строка содержит целое число t — количество минут, за которое Бемби желает добраться до города n (1 ≤ t ≤ 10¹⁸).

### Формат выходных данных
Выведите "Possible" если Бемби сможет достичь цели ровно за t минут, иначе выведите "Impossible".

### Пример
| стандартный ввод | стандартный вывод |
| --- | --- |
| 3 3<br>1 3 7<br>1 2 6<br>2 3 5<br>11 | Possible |
| 3 3<br>1 3 7<br>1 2 6<br>2 3 5<br>25 | Possible |
| 2 1<br>1 2 1<br>9 | Possible |
| 2 1<br>2 1 1<br>1000000000000000000 | Impossible |
| 4 3<br>1 3 10<br>1 2 10<br>2 3 10<br>1000 | Impossible |

## Задача H. Игра
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан ориентированный невзвешенный ациклический граф. На одной из вершин графа стоит «фишка». Двое играют в игру. Пусть «фишка» находится в вершине u, и в графе есть ребро (u,v). Тогда за ход разрешается перевести «фишку» из вершины u в вершину v. Проигрывает тот, кто не может сделать ход.

### Формат входных данных
В первой строке входного файла находятся три натуральных числа N, M и S (1 ≤ N,S,M ≤ 100 000) — количество вершин рёбер и вершина, в которой находится «фишка» в начале игры соответственно. Далее в M строках перечислены рёбра графа. Каждое ребро задаётся парой чисел — номерами начальной и конечной вершин.

### Формат выходных данных
Если выигрывает игрок, который ходит первым, выведите «First player wins», иначе — «Second player wins».

### Пример
| стандартный ввод | стандартный вывод |
| --- | --- |
| 3 3 1<br>1 2<br>2 3<br>1 3 | First player wins |
| 3 2 1<br>1 2<br>2 3 | Second player wins |

**[Решение/Solution](src/h.cpp)**

## Задача I. Ретроанализ для маленьких
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан ориентированный весёлый граф из n вершин и m ребер. Оля и Коля в игру. Изначально фишка стоит в вершине i. За ход можно передвинуть фишку по любому из исходящих ребер. Тот, кто не может сделать ход, проигрывает. Ваша задача — для каждой вершины i определить, кто выиграет при оптимальной игре обоих.

### Формат входных данных
Входные данные состоят из одного или нескольких тестов. Каждый тест содержит описание ориентированного графа. Граф описывается так: на первой строке записаны два целых числа n (1 ≤ n ≤ 300 000) и m (1 ≤ m ≤ 300 000). Следующие m строк содержат ребра графа, каждое описывается парой целых чисел от 1 до n. Пара a b обозначает, что ребро ведет из вершины a в вершину b. В графе могут быть петли и кратные ребра.  
Сумма n по всем тестам не превосходит 300 000, сумма m по всем тестам также не превосходит 300 000.

### Формат выходных данных
Для каждого теста выведите для каждой вершины FIRST, SECOND или DRAW в зависимости от того, кто выиграет при оптимальной игре из этой вершины. Ответы к тестам разделяйте пустой строкой.

### Пример
| стандартный ввод | стандартный вывод |
| --- | --- |
| 5 5<br>1 2<br>2 3<br>3 1<br>1 4<br>4 5<br>2 1<br>1 2<br>4 4<br>1 2<br>2 3<br>3 1<br>1 4 | DRAW<br>DRAW<br>DRAW<br>FIRST<br>SECOND<br><br>FIRST<br>SECOND<br><br>FIRST<br>FIRST<br>SECOND<br>SECOND |

**[Решение/Solution](src/i.cpp)**

## Задача J. Функция Гранди
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Дан ориентированный ациклический граф. Посчитайте функцию Гранди для каждой стартовой вершины.

### Формат входных данных
На первой строке будут даны числа n и m — количество вершин и рёбер в графе (1 ≤ n,m ≤ 100 000). На следующих m строках содержится по два числа x и y (1 ≤ x,y ≤ n).  
Учтите, что в графе могут быть кратные рёбра.

### Формат выходных данных
Выведите n чисел — значение функции Гранди для каждой стартовой вершины.

### Пример
| стандартный ввод | стандартный вывод |
| --- | --- |
| 3 3<br>1 2<br>2 3<br>1 3 | 2<br>1<br>0 |

## Задача K. Дровосек
> Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  
  Ввод: стандартный ввод  
  Вывод: стандартный вывод

Двое играют в следующую игру: имеется дерево с отмеченной вершиной (корнем). Игроки ходят по очереди. За ход игрок рузрубает ветку (стирает ребро), причем из двух получившихся компонент связности остается только та, которая содержит корень — остальная отваливается и больше в игре не участвует. Проигрывает тот, кто не может сделать ход. Определите, может ли выиграть первый игрок, и если да, то укажите любой из его выигрышных ходов.

### Формат входных данных
В первой строке входного файла находятся 2 числа, N и R — количество вершин дерева и номер корня (1 < N ≤ 100 000, 1 ≤ R ≤ N). Далее следуют N−1 строка, в каждой из которых находятся два числа — номера вершин, которые соединяет очередное ребро.

### Формат выходных данных
Выведите в выходной файл одно число 1 или 2 — номер игрока, который выигрывает при правильной игре. Если выигрывает первый игрок, то выведите также любой его выигрышный ход, т.е. порядковый номер ребра во входном файле, которое ему достаточно разрубить первым ходом (число от 1 до N−1).

### Пример
| стандартный ввод | стандартный вывод |
| --- | --- |
| 1 1 | 2 |
| 2 2<br>1 2 | 1<br>1 |