# Лабораторная работа по матроидам
## Задача A. Планирование заданий
> Имя входного файла: schedule.in  
  Имя выходного файла: schedule.out  
  Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  

Имеется некоторое множество заданий и один исполнитель. На выполнение одного задания уходит единица времени. Задания можно выполнять начиная с момента времени 0. У каждого задания
есть две характеристики: dᵢ и wᵢ. Если задание не было выполнено к моменту времени dᵢ, взимается
штраф в размере wᵢ. Требуется минимизировать суммарный штраф.

### Формат входного файла
Первая строка входного файла содержит натуральное число n — количество заданий (1 ≤ n ≤ 100 000). Следующие n строк содержат по два натуральных числа, разделенных пробелом
— dᵢ и wᵢ (0 ≤ dᵢ, wᵢ ≤ 10⁹)

### Формат выходного файла
Выведите одно число — минимальный суммарный штраф.

### Примеры
| schedule.in | schedule.out
| --- | --- |
| 2<br>1 1<br>1 2 | 1 |

**[Решение/Solution](src/a.cpp)**

## Задача B. Уничтожение графа
> Имя входного файла: destroy.in  
  Имя выходного файла: destroy.out  
  Ограничение по времени: 2 секунды  
  Ограничение по памяти: 64 мегабайта  

Дан связный взвешенный граф. Требуется уничтожить максимальное количество ребер, чтобы
были выполнены следующие условия: суммарная стоимость уничтоженных ребер не превосходила
s, оставшийся после уничтожения граф должен быть связен.

### Формат входного файла
Первая строка входного файла содержит числа n и m — количество вершин и ребер в графе, и s — максимальную суммарную стоимость уничтоженных ребер (2 ≤ n ≤ 50 000, 1 ≤ m ≤ 100 000, 0 ≤ s ≤ 10¹⁸). Следующие m строк описывают ребра — для каждого ребра указаны номера вершин, которые оно соединяет, и стоимость уничтожения этого ребра (не превышает 10¹⁸).

### Формат выходного файла
На первой строке выходного файла выведите максимальное количество ребер, которые можно
уничтожить. На второй строке выведите их номера в порядке возрастания (ребра нумеруются с
единицы в порядке, в котором они заданы во входном файле).

### Примеры
| destroy.in | destroy.out
| --- | --- |
| 6 7 10<br>1 2 3<br>1 3 3<br>2 3 3<br>3 4 1<br>4 5 5<br>5 6 4<br>4 6 5 | 2<br>1 5 |

**[Решение/Solution](src/b.cpp)**

## Задача C. Паросочетание максимального веса
> Имя входного файла: matching.in  
  Имя выходного файла: matching.out  
  Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  

Дан двудольный граф. Количество вершин в левой и правой доле совпадает и равно n. У каждой
вершины левой доли есть вес, i-й вершине соответствует вес wᵢ. Вес просочетания, ребрам которого инцидентны вершины левой доли a₁, a₂, ..., aₖ есть √∑ᵢ₌₁..ₖw²ₐᵢ. Требуется найти паросочетание
максимального веса.

### Формат входного файла
Первая строка входного файла содержит натуральное число n — количество вершин в обеих
долях (1 ≤ n ≤ 1000). Вторая строка входного файла содержит n целых чисел w₁, w₂, ..., wₙ
(1 ≤ wᵢ ≤ 1000). Следующие n строк содержат описания ребер, инцидентных соответствующей
вершине левой доли. Формат описания: количество ребер, затем номера вершин правой доли, раз-
деленные пробелом. Суммарное количество ребер не превосходит 200000.

### Формат выходного файла
Выведите n чисел — для каждой вершины левой доли выведите номер вершины правой доли, с
которой ее надо взять в паросочетание. Если вершина не входит в паросочетание, выведите 0.

### Примеры
| matching.in | matching.out
| --- | --- |
| 4<br>1 3 2 4<br>4 1 2 3 4<br>2 1 4<br>2 1 4<br>2 1 4 | 2 1 0 4 |

**[Решение/Solution](src/c.cpp)**

## Задача D. Проверка
> Имя входного файла: check.in  
  Имя выходного файла: check.out  
  Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  

Дано некоторое семейтво множеств S ⊂ 2ˣ. Требуется проверить, может ли S быть семейством
независимых множеств некоторого матроида.

### Формат входного файла
Первая строка входного файла содержит два натуральных числа n и m — мощность множеств X и S соответственно (1 ≤ n ≤ 10, 0 ≤ m ≤ 2ⁿ). Каждая из следующих m строк содержит описание
элемента множества S. Формат описания: количество элементов в подмножестве, затем через пробел
номера этих элементов. Элементы множества X занумерованы начиная с единицы.

### Формат выходного файла
Выведите «YES», если S может быть семейством независимых множеств некоторого матроида и
«NO» иначе.

### Примеры
| check.in | check.out
| --- | --- |
| 2 4<br>0<br>1 1<br>1 2<br>2 1 2 | YES |
| 2 3<br>0<br>1 1<br>2 1 2 | NO |

**[Решение/Solution](src/d.cpp)**

## Задача E. Циклы
> Имя входного файла: cycles.in  
  Имя выходного файла: cycles.out  
  Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  

Дано некоторое семейство множеств S ⊂ 2ˣ. Известно, что это множество циклов некоторого
матроида. Кроме того, у каждого элемента множества X есть свой вес. Вес подможества X есть
сумма весов элементов, принадлежащих ему. Требуется найти базу максимального веса.

### Формат входного файла
Первая строка входного файла содержит два натуральных числа n и m — мощность множеств
X и S соответственно (1 ≤ n ≤ 20). Вторая строка входного файла содержит n чисел w₁, w₂, ..., wₙ (1 ≤ wᵢ ≤ 1000). Здесь элементы множества X занумерованы начиная с единицы и wᵢ — вес i-го элемета множества X. Каждая из следующих m строк содержит описание элемента множества S.
Формат описания: количество элементов в подмножестве, затем через пробел номера этих элементов.

### Формат выходного файла
Выведите одно число — вес максимальной базы.

### Примеры
| cycles.in | cycles.out
| --- | --- |
| 3 1<br>10 20 30<br>3 1 3 2 | 50 |

**[Решение/Solution](src/e.cpp)**

## Задача F. Разноцветные леса
> Имя входного файла: rainbow.in  
  Имя выходного файла: rainbow.out  
  Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  

Дан связный граф с n вершинами и m ребрами. Для каждого ребра известен его цвет. Требуется
найти максимальный по мощности лес в графе, все ребра в котором имеют различный цвет.

### Формат входного файла
Первая строка входного файла содержит два целых числа n и m (1 ≤ n ≤ 100, 0 ≤ m ≤ 5000).
Следующие m строк содержат описание ребер, по одному на строке, i-я из этих строк содержит
три числа: aᵢ bᵢ cᵢ, где aᵢ и bᵢ — номера вершин, соединенных i-м ребром, а cᵢ — цвет этого ребра
(1 ≤ aᵢ≠bᵢ ≤ n, 1 ≤ cᵢ ≤ 100).

### Формат выходного файла
На первой строке выходного файла выведите число k — максимальное количество ребер в раз-
ноцветном лесу. После этого выведите k чисел — номера этих ребер.  
Если есть несколько решений, можно вывести любое.

### Примеры
| rainbow.in | rainbow.out
| --- | --- |
| 4 5<br>1 2 1<br>3 1 1<br>2 3 1<br>1 4 2<br>3 4 3 | 3<br>1 4 5 |
| 4 6<br>1 2 1<br>2 1 2<br>2 3 1<br>3 2 2<br>3 4 1<br>4 3 2 | 2<br>4 1 |

**[Решение/Solution](src/f.cpp)**

## Задача G. Мультиостовное дерево
> Имя входного файла: multispan.in  
  Имя выходного файла: multispan.out  
  Ограничение по времени: 2 секунды  
  Ограничение по памяти: 256 мегабайт  

Дан связный неориентированный граф с n вершинами и m ребрами. Требуется найти макси-
мальное количество реберно непересекающихся остовных деревьев.

### Формат входного файла
Первая строка входного файла содержит два целых числа n и m (2 ≤ n ≤ 100, 0 ≤ m ≤ 2000).
Следующие m строк содержат описание ребер, по одному на строке, i-я из этих строк содержит три
числа: aᵢ bᵢ, где aᵢ и bᵢ — номера вершин, соединенных i-м ребром (1 ≤ aᵢ≠bᵢ ≤ n).

### Формат выходного файла
На первой строке выходного файла выведите число k — максимальное количество реберно непе-
ресекающихся остовных деревьев в этом графе. После этого выведите k строк. Каждая строка
должна содержать n − 1 число — номера ребер в соответствующем остовном дереве.  
Если есть несколько решений, можно вывести любое.

### Примеры
| multispan.in | multispan.out
| --- | --- |
| 3 4<br>1 2<br>2 3<br>3 1<br>3 2 | 2<br>1 2<br>3 4 |

**[Решение/Solution](src/g.cpp)**