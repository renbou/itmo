\documentclass[times]{itmo-student-thesis}

%% Список источников в отдельном файле.
\usepackage{filecontents}
\begin{filecontents}{bachelor-thesis.bib}
@book{ bellman,
    author      = {R. E. Bellman},
    title       = {Dynamic Programming},
    address     = {Princeton, NJ},
    publisher   = {Princeton University Press},
    numpages    = {342},
    pagetotal   = {342},
    year        = {1957},
    langid      = {english}
}
\end{filecontents}
\addbibresource{bachelor-thesis.bib}

\begin{document}

%% \publishyear нужен для \printmainbibliography, которая далее выводит список источников по годам. 
\publishyear{2024}
%% \maketitle отредактирован, чтобы не выводить титульный лист и остальные страницы, т.к. они сейчас не нужны.
\maketitle{Бакалавр}

%%%%
%% Оглавление
%%%%
\tableofcontents

%%%%
%% Введение
%%%%
\startprefacepage

Разработка многих видов промышленного программного обеспечения (ПО) требует построения систем, распределенных по различным узлам исполнения,
которые могут быть представлены как отдельными серверами, расположенными в одном или нескольких датацентрах, так и виртуальными машинами, изолированными в пределах одного сервера,
или даже контейнерами, запускающимися на различного рода средах исполнения, таких как Docker или Kubernetes.
Распределенные системы применяются при разработке ПО, например, для улучшения таких качеств, как масштабируемость и отказоустойчивость,
что безусловно важно для ПО множества компаний с постоянно растущими объемами обрабатываемых данных,
а также для разбиения ПО на более гранулярные компоненты, что в свою очередь упрощает разработку и всей системы в целом.
Такой подход к проектированию ПО часто называется «микросервисной архитектурой», и особенно популярен среди крупных компаний,
одновременно занимающихся разработкой ПО совершенно разной направленности, например: Яндекс Еда и Яндекс Директ, маркетплейс Озон и Озон Путешествия, Тинькофф Банк и Тинькофф Инвестиции. 

Абстрагируясь от архитектуры какой-либо конкретной распределенной системы, общепринятым способом построения связи в ПО, расположенным на различных узлах исполнения,
становятся сетевые вызовы, исполняющиеся в большинстве своем с использованием протоколов TCP или UDP, которые четко стандартизованы и позволяют устанавливать связь между
узлами исполнения независимо от конфигурации их вычислительных характеристик и используемых операционных систем, систем виртуализации или контейнеризации, и других подобных отличий.
Однако, сами TCP и UDP зачастую являются протоколами чересчур низкого уровня для разработчиков, так как предоставляют интерфейсы потоковой и блочной передачи данных
без дополнительного разделения на пакеты, без поддержки сессий или другой группировки данных в рамках одного соединения, без встроенных возможностей передачи метаданных.
Несмотря на указанные минусы, эти протоколы предоставляют качественный фундамент, на основании которого строятся уже более специализированные и удобные протоколы.
В рамках этой работы, однако, нам подробно понадобится рассмотреть именно протокол HTTP в его различных версиях, в частности, HTTP/2.0.

Связывая вышесказанное, перейдем к рассмотрению главного фокуса данной работы — протокола gRPC. Протокол gRPC был разработан Google специально для решения проблем
связывания распределенных систем по сети, и выпущен в открытый доступ в 2015 году сразу с поддержкой множества популярных языков программирования:
C++, Java, Go, Node.js, Python, и другие. gRPC основан на HTTP/2.0, который он использует для предоставления разработчикам унифицированного интерфейса со множеством возможностей,
наиболее важными из которых, на мой взгляд, являются:
\begin{enumerate}
    \item Исполнение обычных (унарных) запросов, состоящих из одной пары запрос/ответ;
    \item Потоковой передачи данных, причем как однонаправленной со стороны клиента/сервера, так и двунаправленной,
          которые часто используются при построении распределенных систем, обрабатывающих изменения данных в режиме реального времени;
    \item Передача дополнительных метаданных в начале запросов и ответов, а также после их завершения,
          что наиболее полезно для предоставления обеим сторонам дополнительных аналитических данных, доступных только после исполнения запроса;
    \item Параллельная обработка запросов в рамках одного соединения, что позволяет эффективно утилизировать низкоуровневое соединение TCP,
          которое используется HTTP/2.0 в качестве транспортного слоя, благодаря разбиению запросов/ответов на небольшие пакеты;
    \item Динамическая отмена исполнения запросов в рамках одного соединения, что важно для минимизации напрасных трат ресурсов систем,
          без накладных расходов в виде долгого пересоздания всего соединения, как было бы при прямом использовании протокола TCP. 
\end{enumerate}

%%%%
%% Первая глава
%%%%
\chapter{Первая глава}

%% Пример ссылок.
Вне обзора:~\cite{bellman}.

\section{Листинги}

В работах студентов кафедры <<Компьютерные технологии>> часто встречаются листинги. Листинги бывают
двух основных видов~--- исходный код и псевдокод. Первый оформляется с помощью окружения \texttt{lstlisting}
из пакета \texttt{listings}, который уже включается в стилевике и немного настроен. Пример Hello World на Java
приведен на листинге~\ref{lst1}.

\begin{lstlisting}[float=!h,caption={Пример исходного кода на Java},label={lst1}]
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
\end{lstlisting}

%%%%
%% Заключение
%%%%
\startconclusionpage

В данном разделе размещается заключение.

\printmainbibliography

%% После этой команды chapter будет генерировать приложения, нумерованные русскими буквами.
%% \startappendices из старого стилевика будет делать то же самое
\appendix

\end{document}
